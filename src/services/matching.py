import asyncio
import re
from sqlalchemy import select, and_, func
from prometheus_client import Counter

from src.database.session import async_session_maker
from src.database.models import UserSurvey, DatingMatch, User
from src.services.rabbit import send_to_queue
from src.bot.keyboards.dating import get_dating_kb

# --- OBSERVABILITY ---
from src.utils.logger import logger
from src.utils.alerting import send_alert

# –ú–µ—Ç—Ä–∏–∫–∞
MATCHES_GENERATED = Counter('rex_dating_matches_total', 'Total matches generated by algorithm')

def _normalize_list(data):
    """–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É '–ë–µ–≥, –ó–∞–ª' –∏–ª–∏ —Å–ø–∏—Å–æ–∫ ['–ë–µ–≥', '–ó–∞–ª'] –≤ set({'–±–µ–≥', '–∑–∞–ª'})."""
    if not data:
        return set()
    if isinstance(data, list):
        return set(str(x).lower().strip() for x in data)
    if isinstance(data, str):
        return set(x.lower().strip() for x in data.split(','))
    return set()

def _parse_int(value, default=0):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç —á–∏—Å–ª–æ –∏–∑ —Å—Ç—Ä–æ–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä '25 –ª–µ—Ç' -> 25)."""
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        # –ò—â–µ–º –≤—Å–µ —Ü–∏—Ñ—Ä—ã
        nums = re.findall(r'\d+', value)
        if nums:
            return int(nums[0])
    return default

async def run_daily_matching():
    """
    –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–¥–±–æ—Ä–∞ –ø–∞—Ä.
    –£—á–∏—Ç—ã–≤–∞–µ—Ç –≥–æ—Ä–æ–¥, –ø–æ–ª, –≤–æ–∑—Ä–∞—Å—Ç –∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –ø–æ –≤–∏–¥–∞–º —Å–ø–æ—Ä—Ç–∞.
    """
    log = logger.bind(task="dating_matching")
    log.info("matching_started")
    
    try:
        async with async_session_maker() as session:
            # 1. –ë–µ—Ä–µ–º –≤—Å–µ—Ö –ê–ö–¢–ò–í–ù–´–• –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –∏—â—É—Ç –ø–∞—Ä—É
            stmt_users = select(UserSurvey).join(User).where(
                and_(
                    UserSurvey.mode == 'dating',
                    User.subscription_expires_at > func.now()
                )
            )
            result = await session.execute(stmt_users)
            seekers = result.scalars().all()
            
            log.info("profiles_fetched", count=len(seekers))
            matches_count = 0

            for me in seekers:
                try:
                    my_id = me.user_id
                    my_data = me.answers or {}
                    
                    # --- –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ò—â—É—â–µ–≥–æ ---
                    my_city = str(my_data.get('city', '')).strip().lower()
                    my_gender = str(my_data.get('gender', '')).lower() # –ú–æ–π –ø–æ–ª
                    
                    # –ö–æ–≥–æ –∏—â—É? (–ï—Å–ª–∏ –≤ –∞–Ω–∫–µ—Ç–µ –µ—Å—Ç—å partner_pref_gender, –±–µ—Ä–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ –ø—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞ –ú<->–ñ)
                    # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –≤ –∞–Ω–∫–µ—Ç–µ –µ—Å—Ç—å –ø–æ–ª—è: partner_gender, partner_age_min, partner_age_max
                    pref_gender = str(my_data.get('partner_gender', '')).lower()
                    if not pref_gender or pref_gender == '–ª—é–±–æ–π':
                        # –§–æ–ª–±—ç–∫: –ú –∏—â–µ—Ç –ñ, –ñ –∏—â–µ—Ç –ú
                        pref_gender = '–∂–µ–Ω—Å–∫–∏–π' if '–º—É–∂' in my_gender else '–º—É–∂—Å–∫–æ–π'

                    pref_age_min = _parse_int(my_data.get('partner_age_min'), 18)
                    pref_age_max = _parse_int(my_data.get('partner_age_max'), 99)
                    
                    # –ú–æ–∏ –≤–∏–¥—ã —Å–ø–æ—Ä—Ç–∞ (–¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π)
                    my_sports = _normalize_list(my_data.get('sports'))

                    # --- –ü–æ–∏—Å–∫ –ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ ---
                    
                    # –ö–æ–≥–æ —è —É–∂–µ –≤–∏–¥–µ–ª?
                    subq_seen = select(DatingMatch.target_user_id).where(DatingMatch.user_id == my_id)
                    
                    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –±–∞—Ç—á –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ (—á—Ç–æ–±—ã –Ω–µ —Ç—è–Ω—É—Ç—å –≤—Å—é –±–∞–∑—É)
                    # –§–∏–ª—å—Ç—Ä—É–µ–º –Ω–∞ —É—Ä–æ–≤–Ω–µ SQL —Å–∞–º–æ–µ –ø—Ä–æ—Å—Ç–æ–µ: —Ä–µ–∂–∏–º + –ø–æ–¥–ø–∏—Å–∫–∞ + –Ω–µ –≤–∏–¥–µ–ª + –Ω–µ —è —Å–∞–º
                    stmt_candidates = select(UserSurvey).join(User).where(
                        and_(
                            UserSurvey.mode == 'dating',
                            User.subscription_expires_at > func.now(),
                            UserSurvey.user_id != my_id,
                            UserSurvey.user_id.not_in(subq_seen)
                        )
                    ).limit(50) # –ë–µ—Ä–µ–º 50 –±–ª–∏–∂–∞–π—à–∏—Ö, —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–∏—Ç–æ–Ω–æ–º
                    
                    candidates_res = await session.execute(stmt_candidates)
                    candidates = candidates_res.scalars().all()
                    
                    best_match = None
                    
                    for cand in candidates:
                        cand_data = cand.answers or {}
                        
                        # 1. –ì–æ—Ä–æ–¥ (–°—Ç—Ä–æ–≥–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
                        cand_city = str(cand_data.get('city', '')).strip().lower()
                        if my_city and cand_city and my_city not in cand_city and cand_city not in my_city:
                            continue # –ù–µ —Ç–æ—Ç –≥–æ—Ä–æ–¥

                        # 2. –ü–æ–ª (–°—Ç—Ä–æ–≥–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
                        cand_gender = str(cand_data.get('gender', '')).lower()
                        if pref_gender and pref_gender not in cand_gender:
                            continue

                        # 3. –í–æ–∑—Ä–∞—Å—Ç (–î–∏–∞–ø–∞–∑–æ–Ω)
                        cand_age = _parse_int(cand_data.get('age'))
                        if not (pref_age_min <= cand_age <= pref_age_max):
                            continue

                        # 4. –°–ø–æ—Ä—Ç (–ï—Å—Ç—å –ª–∏ —Ö–æ—Ç—å –æ–¥–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ?)
                        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —É–∫–∞–∑–∞–ª —Å–ø–æ—Ä—Ç, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –µ–º—É –≤—Å—ë —Ä–∞–≤–Ω–æ
                        cand_sports = _normalize_list(cand_data.get('sports'))
                        if my_sports and cand_sports:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤ (intersection)
                            if not (my_sports & cand_sports):
                                continue # –ù–µ—Ç –æ–±—â–∏—Ö –∏–Ω—Ç–µ—Ä–µ—Å–æ–≤

                        # –ï—Å–ª–∏ –¥–æ—à–ª–∏ —Å—é–¥–∞ ‚Äî –∫–∞–Ω–¥–∏–¥–∞—Ç –ø–æ–¥—Ö–æ–¥–∏—Ç!
                        best_match = cand
                        break # –ù–∞—à–ª–∏ –æ–¥–Ω–æ–≥–æ, —Ö–≤–∞—Ç–∏—Ç
                    
                    if not best_match:
                        continue # –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–∞—Ä —Å–µ–≥–æ–¥–Ω—è

                    # --- –û—Ç–ø—Ä–∞–≤–∫–∞ –ê–Ω–∫–µ—Ç—ã ---
                    cand_data = best_match.answers or {}
                    
                    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫—Ä–∞—Å–∏–≤—ã–π —Ç–µ–∫—Å—Ç
                    # –ò–º—è, –í–æ–∑—Ä–∞—Å—Ç | –í–∏–¥ —Å–ø–æ—Ä—Ç–∞ | –£—Ä–æ–≤–µ–Ω—å
                    info_line = f"{cand_data.get('name', '–ê–Ω–æ–Ω–∏–º')}, {cand_data.get('age', '??')}"
                    
                    sports_str = ", ".join(cand_data.get('sports', '').split(',')) if isinstance(cand_data.get('sports'), str) else "–°–ø–æ—Ä—Ç"
                    level = cand_data.get('level', '–õ—é–±–∏—Ç–µ–ª—å')
                    
                    caption = (
                        f"üéØ <b>–í–∞–º –ø–æ–¥–æ–±—Ä–∞–Ω–∞ –ø–∞—Ä–∞!</b>\n\n"
                        f"üë§ <b>{info_line}</b>\n"
                        f"üìç {cand_data.get('city', '–ì–æ—Ä–æ–¥')}\n"
                        f"üèÖ {sports_str} ({level})\n\n"
                        f"‚ÑπÔ∏è {cand_data.get('about', '')}"
                    )
                    
                    msg_data = {
                        "user_id": my_id,
                        "text": caption,
                        "photo": cand_data.get('photo'),
                        "keyboard": get_dating_kb(best_match.user_id).model_dump()
                    }
                    
                    await send_to_queue("q_notifications", msg_data)
                    
                    MATCHES_GENERATED.inc()
                    matches_count += 1
                    
                    await asyncio.sleep(0.05)

                except Exception as loop_e:
                    log.error("error_processing_user", user_id=me.user_id, error=str(loop_e))
                    continue

            log.info("matching_completed", matches_created=matches_count)

    except Exception as e:
        log.error("matching_critical_failure", error=str(e))
        await send_alert(e, context="Dating Matching Service")
        raise e